local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local localPlayer = Players.LocalPlayer

getgenv().whscript = "KZ HUB" 
getgenv().webhookexecUrl = "https://discord.com/api/webhooks/1436634012293791906/r66W_prYP7yMCtkRpcfiCdEW7uxtgCyqtDZHTknfjcHjyQsThZi04Tbi4fyU33gKeqRu"
getgenv().ExecLogSecret = false -- N·∫øu mu·ªën log IP v√† location, ƒë·∫∑t true

local ui = gethui()
local folderName = "screen"
local folder = Instance.new("Folder")
folder.Name = folderName
local player = game:GetService("Players").LocalPlayer

if not ui:FindFirstChild(folderName) then
    folder.Parent = gethui()

    local players = game:GetService("Players")
    local userid = player.UserId
    local gameid = game.PlaceId
    local jobid = tostring(game.JobId)
    local gameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
    local completeTime = os.date("%Y-%m-%d %H:%M:%S")
    local position = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position or "N/A"
    local health = player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health or "N/A"
    local maxHealth = player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.MaxHealth or "N/A"

    local data = {
        ["content"] = "",
        ["embeds"] = {{
            ["title"] = "**Script Execution Detected | Exec Log**",
            ["description"] = "A script was executed. Details below:",
            ["type"] = "rich",
            ["color"] = 0x3498db,
            ["fields"] = {
                {
                    ["name"] = "Script Info",
                    ["value"] = "Script Name: " .. getgenv().whscript .. "\nExecuted At: " .. completeTime,
                    ["inline"] = false
                },
                {
                    ["name"] = "Player Details",
                    ["value"] = "Username: " .. player.Name ..
                                "\nDisplay Name: " .. player.DisplayName ..
                                "\nUserID: " .. userid ..
                                "\nHealth: " .. health .. " / " .. maxHealth ..
                                "\nProfile: https://www.roblox.com/users/" .. userid .. "/profile",
                    ["inline"] = false
                },
                {
                    ["name"] = "Character Position",
                    ["value"] = tostring(position),
                    ["inline"] = false
                }
            }
        }}
    }

    local newdata = game:GetService("HttpService"):JSONEncode(data)
    local headers = { ["content-type"] = "application/json" }
    local request = http_request or request or (syn and syn.request) or (fluxus and fluxus.request) or (http and http.request)
    request({Url = getgenv().webhookexecUrl, Body = newdata, Method = "POST", Headers = headers})
end

local core = nil
pcall(function()
    core = require(RS:WaitForChild("Core"))
end)

local screenGui = Instance.new("ScreenGui", localPlayer:WaitForChild("PlayerGui"))
screenGui.Name = "KFC_HUB_FULL"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true

local mainFrame = Instance.new("Frame", screenGui)
mainFrame.Size = UDim2.new(0,440,0,360)
mainFrame.Position = UDim2.new(0.5,-220,0.35,-180)
mainFrame.BackgroundColor3 = Color3.fromRGB(26,26,26)
mainFrame.Active = true
mainFrame.Draggable = true
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0,8)

local uiScale = Instance.new("UIScale")
uiScale.Scale = 0.85  
uiScale.Parent = mainFrame

local header = Instance.new("Frame", mainFrame)
header.Size = UDim2.new(1,0,0,36)
header.Position = UDim2.new(0,0,0,0)
header.BackgroundColor3 = Color3.fromRGB(40,40,40)
Instance.new("UICorner", header).CornerRadius = UDim.new(0,6)

local title = Instance.new("TextLabel", header)
title.Size = UDim2.new(1,-110,1,0)
title.Position = UDim2.new(0,12,0,0)
title.BackgroundTransparency = 1
title.Text = " KZ HUB | Discord: kfc_3012"
title.TextColor3 = Color3.fromRGB(255,255,255)
title.TextXAlignment = Enum.TextXAlignment.Left
title.Font = Enum.Font.GothamBold
title.TextSize = 15

-- Minimize / Close
local minimizeBtn = Instance.new("TextButton", header)
minimizeBtn.Size = UDim2.new(0,34,0,28)
minimizeBtn.Position = UDim2.new(1,-82,0,4)
minimizeBtn.Text = "‚Äî"
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 18
minimizeBtn.BackgroundColor3 = Color3.fromRGB(180,50,50)
minimizeBtn.TextColor3 = Color3.fromRGB(255,255,255)
Instance.new("UICorner", minimizeBtn).CornerRadius = UDim.new(0,6)

local closeBtn = Instance.new("TextButton", header)
closeBtn.Size = UDim2.new(0,34,0,28)
closeBtn.Position = UDim2.new(1,-42,0,4)
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 16
closeBtn.BackgroundColor3 = Color3.fromRGB(150,0,0)
closeBtn.TextColor3 = Color3.fromRGB(255,255,255)
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0,6)

-- small open button after minimize (mini UI)
local openSmall = Instance.new("TextButton", screenGui)
openSmall.Size = UDim2.new(0,55,0,55)
openSmall.Position = UDim2.new(0.05, 0, 0.2, 0)
openSmall.Text = "KZ"
openSmall.Visible = false
openSmall.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
openSmall.TextColor3 = Color3.fromRGB(255, 255, 255)
openSmall.Font = Enum.Font.GothamBold
openSmall.TextSize = 16
openSmall.Active = true
openSmall.Draggable = true

-- bo tr√≤n ho√†n to√†n
local corner = Instance.new("UICorner", openSmall)
corner.CornerRadius = UDim.new(1, 0)

-- th√™m vi·ªÅn s√°ng nh·∫π
local stroke = Instance.new("UIStroke", openSmall)
stroke.Thickness = 1.5
stroke.Color = Color3.fromRGB(255, 255, 255)
stroke.Transparency = 0.4

-- hi·ªáu ·ª©ng hover
openSmall.MouseEnter:Connect(function()
	openSmall.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	stroke.Transparency = 0
end)
openSmall.MouseLeave:Connect(function()
	openSmall.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	stroke.Transparency = 0.4
end)

-- s·ª± ki·ªán thu nh·ªè v√† m·ªü l·∫°i UI
minimizeBtn.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	openSmall.Visible = true
end)

openSmall.MouseButton1Click:Connect(function()
	mainFrame.Visible = true
	openSmall.Visible = false
end)

closeBtn.MouseButton1Click:Connect(function()
	screenGui.Enabled = false
end)
-- Tabs
local tabsFrame = Instance.new("Frame", mainFrame)
tabsFrame.Size = UDim2.new(1,-20,0,36)
tabsFrame.Position = UDim2.new(0,10,0,44)
tabsFrame.BackgroundTransparency = 1

-- ===== makeTabBtn m·ªõi h·ªó tr·ª£ N tab v√† t·∫°o 3 tab ƒë·ªÅu nhau =====
local function makeTabBtn(text, index, total)
    local widthScale = 1 / total
    local posScale = (index - 1) / total
    local b = Instance.new("TextButton", tabsFrame)
    b.Size = UDim2.new(widthScale, -12, 1, 0)
    b.Position = UDim2.new(posScale, 6, 0, 0)
    b.Text = text
    b.BackgroundColor3 = Color3.fromRGB(36,36,36)
    b.TextColor3 = Color3.fromRGB(200,200,200)
    b.Font = Enum.Font.Gotham
    b.TextSize = 14
    b.AutoButtonColor = true
    Instance.new("UICorner", b).CornerRadius = UDim.new(0,6)
    return b
end

-- T·∫°o 3 tab: Combat, Utility, Exploits
local totalTabs = 3
local tabCombatBtn = makeTabBtn("Combat", 1, totalTabs)
local tabUtilBtn    = makeTabBtn("Emote", 2, totalTabs)
local tabExploitBtn = makeTabBtn("Exploits", 3, totalTabs)

-- Content area
local contentFrame = Instance.new("Frame", mainFrame)
contentFrame.Size = UDim2.new(1,-20,1,-96)
contentFrame.Position = UDim2.new(0,10,0,84)
contentFrame.BackgroundTransparency = 1

-- Frames cho t·ª´ng tab
local combatFrame = Instance.new("ScrollingFrame", contentFrame)
combatFrame.Size = UDim2.new(1,0,1,0)
combatFrame.CanvasSize = UDim2.new(0,0,2,0)
combatFrame.ScrollBarThickness = 6
combatFrame.BackgroundTransparency = 1
combatFrame.Visible = true

local utilFrame = Instance.new("Frame", contentFrame)
utilFrame.Size = UDim2.new(1,0,1,0)
utilFrame.BackgroundTransparency = 1
utilFrame.Visible = false

local exploitsFrame = Instance.new("Frame", contentFrame)
exploitsFrame.Size = UDim2.new(1,0,1,0)
exploitsFrame.BackgroundTransparency = 1
exploitsFrame.Visible = false

-- Ch·ª©c nƒÉng chuy·ªÉn tab
tabCombatBtn.MouseButton1Click:Connect(function()
    combatFrame.Visible = true
    utilFrame.Visible = false
    exploitsFrame.Visible = false
end)
tabUtilBtn.MouseButton1Click:Connect(function()
    combatFrame.Visible = false
    utilFrame.Visible = true
    exploitsFrame.Visible = false
end)
tabExploitBtn.MouseButton1Click:Connect(function()
    combatFrame.Visible = false
    utilFrame.Visible = false
    exploitsFrame.Visible = true
end)

-- helper to create buttons/textboxes in frames
local function createButton(parent, text, posY)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(1,-20,0,34)
    btn.Position = UDim2.new(0,10,0,posY)
    btn.Text = text
    btn.BackgroundColor3 = Color3.fromRGB(44,44,44)
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)
    return btn
end
local function createTextBox(parent, placeholder, posY, default)
    local box = Instance.new("TextBox", parent)
    box.Size = UDim2.new(1,-20,0,28)
    box.Position = UDim2.new(0,10,0,posY)
    box.PlaceholderText = placeholder
    box.Text = tostring(default)
    box.BackgroundColor3 = Color3.fromRGB(60,60,60)
    box.TextColor3 = Color3.fromRGB(255,255,255)
    box.Font = Enum.Font.Gotham
    box.TextSize = 14
    Instance.new("UICorner", box).CornerRadius = UDim.new(0,6)
    return box
end

-- ----------------------------
-- Insert ORIGINAL combat logic (kept intact)
-- ----------------------------

-- ---------- Kill Aura FIXED ON/OFF ----------
local KillAuraBtn
local killAuraRunning = false
local lastDash = 0
local distance = 100 -- default Kill Aura range
local Configs = {
    IgnoreFriends = false,
    MaxDistance = distance,
    Damage = 1,
    HealthLimit = 0,
    DashInterval = 0.7
}

local function triggerDash()
    if tick() - lastDash < Configs.DashInterval then return end
    lastDash = tick()
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local dashArgs = {[1]=hrp.CFrame,[2]="L",[3]=hrp.CFrame.LookVector,[5]=tick()}
    local dashRemote = RS.Remotes.Character:FindFirstChild("Dash")
    if dashRemote then pcall(function() dashRemote:FireServer(unpack(dashArgs)) end) end
end

local function sendKillAura()
    local Character = localPlayer.Character
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then return end
    local CharactersFolder = RS:FindFirstChild("Characters")
    local RemotesFolder = RS:FindFirstChild("Remotes")
    if not CharactersFolder or not RemotesFolder then return end
    local AbilitiesRemote = RemotesFolder:FindFirstChild("Abilities")
    local CombatRemote = RemotesFolder:FindFirstChild("Combat")
    if AbilitiesRemote then AbilitiesRemote = AbilitiesRemote:FindFirstChild("Ability") end
    if CombatRemote then CombatRemote = CombatRemote:FindFirstChild("Action") end
    if not AbilitiesRemote or not CombatRemote then return end
    local CharacterName = localPlayer:FindFirstChild("Data") and localPlayer.Data:FindFirstChild("Character") and localPlayer.Data.Character.Value
    if not CharacterName then return end
    local WallCombo = CharactersFolder:FindFirstChild(CharacterName)
    if not WallCombo then return end
    WallCombo = WallCombo:FindFirstChild("WallCombo")
    if not WallCombo then return end
    local localRootPart = Character.HumanoidRootPart
    triggerDash()
    for _, targetPlayer in ipairs(Players:GetPlayers()) do
        if targetPlayer == localPlayer then continue end
        if not targetPlayer.Character then continue end
        if not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then continue end
        if Configs.IgnoreFriends and localPlayer:IsFriendsWith(targetPlayer.UserId) then continue end
        local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        local targetRootPart = targetPlayer.Character.HumanoidRootPart
        if not targetHumanoid or targetHumanoid.Health <= Configs.HealthLimit then continue end
        local distanceToTarget = (localRootPart.Position - targetRootPart.Position).Magnitude
        if distanceToTarget > Configs.MaxDistance then continue end
        local abilityArgs = {WallCombo, Configs.Damage, {}, targetRootPart.Position}
        pcall(function() AbilitiesRemote:FireServer(unpack(abilityArgs)) end)
        local startCFrameStr = tostring(localRootPart.CFrame)
        local combatArgs = {
            WallCombo, CharacterName..":WallCombo", 2,
            Configs.Damage,
            {HitboxCFrames={targetRootPart.CFrame,targetRootPart.CFrame},BestHitCharacter=targetPlayer.Character,HitCharacters={targetPlayer.Character},Ignore={},DeathInfo={},BlockedCharacters={},HitInfo={IsFacing=false,IsInFront=true},ServerTime=os.time(),Actions={ActionNumber1={[targetPlayer.Name]={StartCFrameStr=startCFrameStr,Local=true,Collision=false,Animation="Punch1Hit",Preset="Punch",Velocity=Vector3.zero,FromPosition=targetRootPart.Position,Seed=math.random(1,999999)}}},FromCFrame=targetRootPart.CFrame},
            "Action150",0
        }
        pcall(function() CombatRemote:FireServer(unpack(combatArgs)) end)
    end
end

local killAuraConn
local function startKillAura()
    if killAuraConn then killAuraConn:Disconnect() killAuraConn=nil end
    killAuraConn = RunService.Heartbeat:Connect(function()
        if killAuraRunning then sendKillAura() end
    end)
end
local function toggleKillAura()
    killAuraRunning = not killAuraRunning
    if KillAuraBtn then
        KillAuraBtn.Text = "Kill Aura: " .. (killAuraRunning and "ON" or "OFF")
    end
    if killAuraRunning then
        startKillAura()
    else
        if killAuraConn then killAuraConn:Disconnect() killAuraConn=nil end
    end
end

-- Connect button (ensure correct ON/OFF display)
if KillAuraBtn then
    KillAuraBtn.MouseButton1Click:Connect(toggleKillAura)
end

-- Fly (kept unchanged)
local flyEnabled = false
local FlyBtn
local function toggleFly()
    flyEnabled = not flyEnabled
    if FlyBtn then FlyBtn.Text = "Fly: " .. (flyEnabled and "ON" or "OFF") end
    if flyEnabled then
        pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/XNEOFF/FlyGuiV3/main/FlyGuiV3.txt"))()
        end)
    end
end

-- Hitbox (kept unchanged)
local hitboxEnabled = false
local hitboxSize = 20
local oldBoxFunc
pcall(function()
    if core and core.Get and core.Get("Combat","Hit") then
        oldBoxFunc = core.Get("Combat","Hit").Box
    end
end)
local HitboxBtn
local function setHitbox(state)
    hitboxEnabled = state
    if HitboxBtn then HitboxBtn.Text = "Hitbox: " .. (state and "ON" or "OFF") end
    if core and oldBoxFunc then
        if state then
            core.Get("Combat","Hit").Box = function(_, target, data)
                return oldBoxFunc(nil, target, {Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)})
            end
        else
            core.Get("Combat","Hit").Box = oldBoxFunc
        end
    end
end

-- Wall Combo (kept unchanged)
local wallComboEnabled = false
local WallBtn
local function toggleWallCombo()
    wallComboEnabled = not wallComboEnabled
    if WallBtn then WallBtn.Text = "Wall Combo: " .. (wallComboEnabled and "ON" or "OFF") end

    local chars = RS:FindFirstChild("Characters")
    if not (core and chars and localPlayer:FindFirstChild("Data") and localPlayer.Data:FindFirstChild("Character")) then
        return warn("‚ö†Ô∏è Kh√¥ng ƒë·ªß module ƒë·ªÉ Wall Combo")
    end
    local function wallcombo()
        local head = localPlayer.Character and localPlayer.Character:FindFirstChild("Head")
        if not head then return end
        local res = core.Get("Combat","Hit").Box(nil, localPlayer.Character, {Size = Vector3.new(50,50,50)})
        if res then
            pcall(core.Get("Combat","Ability").Activate, chars[localPlayer.Data.Character.Value].WallCombo, res, head.Position + Vector3.new(0,0,2.5))
        end
    end
    if wallComboEnabled then
        RunService:BindToRenderStep("WallCombo", Enum.RenderPriority.Input.Value, wallcombo)
    else
        RunService:UnbindFromRenderStep("WallCombo")
    end
end

-- ---------- Add Auto Block (with ON/OFF) ----------
local autoBlockEnabled = false
local BlockRemote = nil
pcall(function()
    BlockRemote = RS:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("Block")
end)

local function enableBlockOnce()
    if BlockRemote then
        pcall(function()
            BlockRemote:FireServer(true)
        end)
    end
end

-- Auto Block loop (runs only when enabled)
task.spawn(function()
    while true do
        task.wait(0.05)
        if autoBlockEnabled then
            local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
            local success, isBlocking = pcall(function()
                return character:GetAttribute("IsBlocking")
            end)
            if success and not isBlocking then
                enableBlockOnce()
            end
        end
    end
end)

-- ---------- Dash no-cooldown (TextBox control, 0-100) ----------
-- default value 1 (like original)
local function setDashCooldownValue(v)
    local success, settings = pcall(function()
        return RS.Settings.Cooldowns
    end)
    if success and settings and settings:FindFirstChild("Dash") then
        local clamped = math.clamp(math.floor(v), 0, 100)
        settings.Dash.Value = clamped
    end
end

-- ---------- Combat UI placements inside combatFrame ----------
-- We'll place buttons sequentially (y positions)
local y = 6
KillAuraBtn = createButton(combatFrame, "Kill Aura: OFF", y); y = y + 44
-- Kill Aura Range TextBox
local killRangeBox = createTextBox(combatFrame, "Kill Aura Range (number)", y, distance); y = y + 36
killRangeBox.FocusLost:Connect(function(enter)
    if enter then
        local n = tonumber(killRangeBox.Text)
        if n then distance = n else killRangeBox.Text = tostring(distance) end
    end
end)
-- We'll place buttons sequentially (y positions)
local y = 6
KillAuraBtn = createButton(combatFrame, "Kill Aura: OFF", y); y = y + 44
-- Kill Aura Range TextBox
local killRangeBox = createTextBox(combatFrame, "Kill Aura Range (number)", y, distance); y = y + 36
killRangeBox.FocusLost:Connect(function(enter)
    if enter then
        local n = tonumber(killRangeBox.Text)
        if n then distance = n else killRangeBox.Text = tostring(distance) end
    end
end)

-- üü¢ Kill Aura Button Function
local killAuraRunning = false
local killAuraConn

KillAuraBtn.MouseButton1Click:Connect(function()
    killAuraRunning = not killAuraRunning
    if killAuraRunning then
        print("üü¢ Kill Aura ON")
        if killAuraConn then killAuraConn:Disconnect() end
        killAuraConn = RunService.Heartbeat:Connect(function()
            sendKillAura()
        end)
        KillAuraBtn.Text = "Kill Aura: ON"
    else
        print("üî¥ Kill Aura OFF")
        if killAuraConn then killAuraConn:Disconnect() killAuraConn = nil end
        KillAuraBtn.Text = "Kill Aura: OFF"
    end
end)


-- ===== Th√™m n√∫t Ignore Friends =====
local ignoreFriendsBtn = createButton(combatFrame, "Ignore Friends: OFF", y); y = y + 44
ignoreFriendsBtn.MouseButton1Click:Connect(function()
    Configs.IgnoreFriends = not Configs.IgnoreFriends
    ignoreFriendsBtn.Text = "Ignore Friends: " .. (Configs.IgnoreFriends and "ON" or "OFF")
end)


local circleBtn = createButton(combatFrame, "Anti God Mode: OFF", y)
y = y + 44

local circleEnabled = false
circleBtn.MouseButton1Click:Connect(function()
    circleEnabled = not circleEnabled
    circleBtn.Text = "Anti God Mode: " .. (circleEnabled and "ON" or "OFF")
    -- TODO: local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local CircleParts = {}
local Connection

local function RainbowColor(t)
    local r = math.sin(t) * 40 + 180
    local g = math.sin(t + 2) * 40 + 180
    local b = math.sin(t + 4) * 40 + 180
    return Color3.fromRGB(r, g, b)
end

Tab:Toggle({
    Title = "circle",
    Value = false,
    Callback = function(state)
        local function CreateCircle(radius, segments, thickness)
            local parts = {}
            for i = 1, segments do
                local part = Instance.new("Part")
                part.Anchored = true
                part.CanCollide = false
                part.Material = Enum.Material.Neon
                part.Size = Vector3.new(thickness, 0.2, radius * 2 * math.pi / segments)
                part.Color = Color3.fromRGB(180,180,180)
                part.Parent = workspace
                table.insert(parts, part)
            end
            return parts
        end

        local function DestroyCircle()
            if Connection then
                Connection:Disconnect()
                Connection = nil
            end
            for _, part in ipairs(CircleParts) do
                if part and part.Parent then
                    part:Destroy()
                end
            end
            CircleParts = {}
        end

        if state then
            DestroyCircle()
            local radius = 60
            local segments = 60
            local thickness = 0.2
            CircleParts = CreateCircle(radius, segments, thickness)

            local time = 0
            local updateAccumulator = 0
            local updateRate = 1/60

            Connection = RunService.RenderStepped:Connect(function(dt)
                time = time + dt
                updateAccumulator = updateAccumulator + dt
                if updateAccumulator < updateRate then return end
                updateAccumulator = 0

                local char = LocalPlayer.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local rootPos = char.HumanoidRootPart.Position
                    local humanoid = char:FindFirstChild("Humanoid")
                    local heightOffset = humanoid and humanoid.HipHeight / 2 + 0.1 or 0.9 -- √§¬∏¬ã√ß¬ß¬ª√§¬∏¬Ä√ß¬Ç¬π√ß¬Ç¬π
                    local pos = rootPos - Vector3.new(0, heightOffset, 0)

                    for i, part in ipairs(CircleParts) do
                        local angle = (i / #CircleParts) * 2 * math.pi
                        local x = pos.X + math.cos(angle) * radius
                        local z = pos.Z + math.sin(angle) * radius
                        part.Position = Vector3.new(x, pos.Y, z)
                        part.Orientation = Vector3.new(0, -math.deg(angle), 0)
                        part.Color = RainbowColor(time + i * 0.1)
                    end
                end
            end)
        else
            DestroyCircle()
        end
    end
})

end)

HitboxBtn = createButton(combatFrame, "Hitbox: OFF", y); y = y + 44
-- Hitbox size textbox
local hitboxBox = createTextBox(combatFrame, "Hitbox Size (number)", y, hitboxSize); y = y + 36
hitboxBox.FocusLost:Connect(function(enter)
    if enter then
        local n = tonumber(hitboxBox.Text)
        if n then hitboxSize = n; if hitboxEnabled then setHitbox(true) end else hitboxBox.Text = tostring(hitboxSize) end
    end
end)

WallBtn = createButton(combatFrame, "Wall Combo: OFF", y); y = y + 44
FlyBtn = createButton(combatFrame, "Fly: OFF", y); y = y + 44

-- === SPAM WALL COMBO V2 (C√ì ON/OFF) ===
local spamWallComboV2Enabled = false
local spamWallComboV2Btn = createButton(combatFrame, "Spam Wall Combo V2: OFF", y)
y = y + 36

spamWallComboV2Btn.MouseButton1Click:Connect(function()
    spamWallComboV2Enabled = not spamWallComboV2Enabled
    spamWallComboV2Btn.Text = "Spam Wall Combo V2: " .. (spamWallComboV2Enabled and "ON" or "OFF")

    if spamWallComboV2Enabled then
        print("‚ö° Spam Wall Combo V2 B·∫¨T (ch∆∞a g·∫Øn code th·∫≠t).")
        -- TODO: 
        -- B·∫Øt ƒë·∫ßu spam wall combo v2
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Core = require(ReplicatedStorage:WaitForChild("Core"))
        local LocalPlayer = Players.LocalPlayer

        local Configs = {
            IgnoreFriends = false,
            MaxDistance = 100,
            Damage = 1,
            HealthLimit = 0,
            DashInterval = 0.7,
            WallSize = Vector3.new(50,50,50)
        }

        local charValue = LocalPlayer:WaitForChild("Data"):WaitForChild("Character").Value
        local WallCombo = ReplicatedStorage:WaitForChild("Characters"):WaitForChild(charValue):WaitForChild("WallCombo")

        local conn
        local lastDash = 0

        local function triggerDash()
            if tick() - lastDash < Configs.DashInterval then return end
            lastDash = tick()
            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local dashArgs = {
                [1] = hrp.CFrame,
                [2] = "L",
                [3] = hrp.CFrame.LookVector,
                [5] = tick()
            }
            local dashRemote = ReplicatedStorage.Remotes.Character:FindFirstChild("Dash")
            if dashRemote then
                pcall(function()
                    dashRemote:FireServer(unpack(dashArgs))
                end)
            end
        end

        local function sendWallAura()
            local Character = LocalPlayer.Character
            if not Character or not Character:FindFirstChild("HumanoidRootPart") then return end
            triggerDash()

            for _, targetPlayer in ipairs(Players:GetPlayers()) do
                if targetPlayer == LocalPlayer then continue end
                if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then continue end
                if Configs.IgnoreFriends and LocalPlayer:IsFriendsWith(targetPlayer.UserId) then continue end
                local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
                if not targetHumanoid or targetHumanoid.Health <= Configs.HealthLimit then continue end

                local distance = (Character.HumanoidRootPart.Position - targetPlayer.Character.HumanoidRootPart.Position).Magnitude
                if distance > Configs.MaxDistance then continue end

                -- G·ªçi Wall Combo
                local res = Core.Get("Combat","Hit").Box(nil, Character, {Size = Configs.WallSize})
                if res then
                    pcall(function()
                        Core.Get("Combat","Ability").Activate(WallCombo, res, targetPlayer.Character.HumanoidRootPart.Position)
                    end)
                end
            end
        end

        conn = RunService.Heartbeat:Connect(function()
            if spamWallComboV2Enabled then
                sendWallAura()
            else
                conn:Disconnect()
            end
        end)
    else
        print("üî¥ Spam Wall Combo V2 T·∫ÆT.")
        -- TODO: N·∫øu c·∫ßn, th√™m code t·∫Øt ch·ª©c nƒÉng ·ªü ƒë√¢y
    end
end)

-- Auto Block toggle
local autoBlockBtn = createButton(combatFrame, "Auto Block: OFF", y); y = y + 44
autoBlockBtn.MouseButton1Click:Connect(function()
    autoBlockEnabled = not autoBlockEnabled
    autoBlockBtn.Text = "Auto Block: " .. (autoBlockEnabled and "ON" or "OFF")
end)

-- Dash cooldown text + box
local dashLabel = Instance.new("TextLabel", combatFrame)
dashLabel.Size = UDim2.new(1,-20,0,20)
dashLabel.Position = UDim2.new(0,10,0,y)
dashLabel.BackgroundTransparency = 1
dashLabel.Text = "Dash Cooldown (0-100):"
dashLabel.TextColor3 = Color3.fromRGB(220,220,220)
dashLabel.Font = Enum.Font.Gotham
dashLabel.TextSize = 13
y = y + 24

local dashBox = createTextBox(combatFrame, "Dash cooldown value (0-100)", y, 1); y = y + 36
dashBox.FocusLost:Connect(function(enter)
    if enter then
        local n = tonumber(dashBox.Text)
        if n then
            local clamped = math.clamp(math.floor(n), 0, 100)
            dashBox.Text = tostring(clamped)
            setDashCooldownValue(clamped)
        else
            dashBox.Text = tostring(1)
            setDashCooldownValue(1)
        end
    end
end)


-- Buttons callbacks for earlier features (connect after created)
KillAuraBtn.MouseButton1Click:Connect(function()
    toggleKillAura()
    KillAuraBtn.Text = "Kill Aura: " .. (killAura and "ON" or "OFF")
end)
HitboxBtn.MouseButton1Click:Connect(function()
    setHitbox(not hitboxEnabled)
end)
WallBtn.MouseButton1Click:Connect(function()
    toggleWallCombo()
end)
FlyBtn.MouseButton1Click:Connect(function()
    toggleFly()
end)

-- Ensure combatFrame canvas size increases if needed
combatFrame:GetPropertyChangedSignal("CanvasPosition"):Connect(function() end)
-- We'll update CanvasSize based on content automatically:
local function updateCombatCanvas()
    local maxY = 0
    for _,v in ipairs(combatFrame:GetChildren()) do
        if v:IsA("GuiObject") and v.Visible then
            local bottom = v.Position.Y.Offset + v.Size.Y.Offset
            if bottom > maxY then maxY = bottom end
        end
    end
    combatFrame.CanvasSize = UDim2.new(0,0,0,math.max(maxY + 24, combatFrame.AbsoluteSize.Y))
end
-- call periodically to adapt
task.spawn(function()
    while true do
        updateCombatCanvas()
        task.wait(0.4)
    end
end)


-----------------------------------------------------
-- üîΩ TH√äM PH·∫¶N N√ÄY V√ÄO SAU N√öT GOD MODE
-----------------------------------------------------

local invisibleEnabled = false
local InvisibleBtn = createButton(combatFrame, "Invisible: OFF", y)
y = y + 44

InvisibleBtn.MouseButton1Click:Connect(function()
    invisibleEnabled = not invisibleEnabled
    InvisibleBtn.Text = "Invisible: " .. (invisibleEnabled and "ON" or "OFF")

    -----------------------------------------------------
    -- ‚ùó B·ªé CODE INVISIBLE C·ª¶A B·∫†N V√ÄO ƒê√ÇY ‚ùó
    -----------------------------------------------------
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Replication"):WaitForChild("FullCustomReplicationUnreliable")
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local HRP = Character:WaitForChild("HumanoidRootPart")

    -- Hook remote ch·ªâ 1 l·∫ßn
    if not getgenv()._InvisibleHooked then
        getgenv()._InvisibleHooked = true
        local mt = getrawmetatable(game)
        setreadonly(mt, false)
        local old = mt.__namecall
        mt.__namecall = function(self, ...)
            if self == Remote and getnamecallmethod() == "FireServer" and getgenv().blockRemote then
                return nil
            end
            return old(self, ...)
        end
        setreadonly(mt, true)
    end

    if invisibleEnabled then
        -- B·∫≠t invisible
        local originalCF = HRP.CFrame
        local flyingCF = originalCF + Vector3.new(0, 50000, 0)

        task.spawn(function()
            for i = 1, 10 do
                HRP.CFrame = flyingCF
                Remote:FireServer()
                task.wait(0.1)
            end
            getgenv().blockRemote = true
            HRP.CFrame = originalCF
        end)
    else
        -- T·∫Øt invisible
        getgenv().blockRemote = false
    end
end)

-- ---------- Fix Lag Button ----------
local y = y + 10  -- ti·∫øp n·ªëi v·ªã tr√≠ hi·ªán t·∫°i c·ªßa c√°c n√∫t
local fixLagBtn = createButton(combatFrame, "Fix Lag", y); y = y + 44
fixLagBtn.MouseButton1Click:Connect(function()
    pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/TurboLite/Script/main/FixLag.lua"))()
    end)
end)


-- Auto Farm & Emote Spam (original code kept intact)
-- ----------------------------

--- Emote Spam (original code kept) ----------
local killEmotes = {
    "Vampire", "Surprise!","ACME","Avra Kadoovra","Baldie's Demise","Barbarian","Bee","Blood Sugar","Cauldron","Curb Stomp","Figure Skater","Frost Breath","Frostbound Prison","Frozen Impalement","Gingerbread","Glacial Burial","Goblin Bomb","Heart Rip","Impostor","Laser Eyes","Mistletoe","Naughty List","Neck Snap","Orthax","Pollen Overload","Possession","Rudolph's Revenge","Selfie","Serious Sneeze","Sick Burn","Smite","Snowball Cannon","Snowflakes","Sore Winner","Spine Breaker","Spirit Trap","Think Mark","Tinsel Strangle","Tree Topper Slice","Werewolf","Wrap It Up"
}

-- Emote UI within utilFrame
local emoteBoxBg = Instance.new("Frame", utilFrame)
emoteBoxBg.Size = UDim2.new(0.92,0,0.52,0)
emoteBoxBg.Position = UDim2.new(0.04,0,0.02,0)
emoteBoxBg.BackgroundColor3 = Color3.fromRGB(30,30,30)
Instance.new("UICorner", emoteBoxBg).CornerRadius = UDim.new(0,6)

local emoteTitle = Instance.new("TextLabel", emoteBoxBg)
emoteTitle.Size = UDim2.new(1,-10,0,28)
emoteTitle.Position = UDim2.new(0,5,0,5)
emoteTitle.BackgroundTransparency = 1
emoteTitle.Text = "Emote Spam"
emoteTitle.TextColor3 = Color3.fromRGB(255,255,255)
emoteTitle.Font = Enum.Font.GothamBold
emoteTitle.TextSize = 16

local dropdown = Instance.new("TextButton", emoteBoxBg)
dropdown.Size = UDim2.new(0.9,0,0,30)
dropdown.Position = UDim2.new(0.05,0,0,40)
dropdown.Text = "Select Emote"
dropdown.BackgroundColor3 = Color3.fromRGB(60,60,60)
dropdown.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", dropdown).CornerRadius = UDim.new(0,6)

local scroll = Instance.new("ScrollingFrame", emoteBoxBg)
scroll.Size = UDim2.new(0.9,0,0,120)
scroll.Position = UDim2.new(0.05,0,0,80)
scroll.Visible = false
scroll.CanvasSize = UDim2.new(0,0,0,#killEmotes*25)
Instance.new("UICorner", scroll).CornerRadius = UDim.new(0,6)

for i,name in ipairs(killEmotes) do
    local b = Instance.new("TextButton", scroll)
    b.Size = UDim2.new(1,0,0,25)
    b.Position = UDim2.new(0,0,0,(i-1)*25)
    b.Text = name
    b.BackgroundColor3 = Color3.fromRGB(80,80,80)
    b.TextColor3 = Color3.new(1,1,1)
    b.MouseButton1Click:Connect(function()
        dropdown.Text = name
        scroll.Visible = false
    end)
    Instance.new("UICorner", b).CornerRadius = UDim.new(0,6)
end

dropdown.MouseButton1Click:Connect(function()
    scroll.Visible = not scroll.Visible
end)

local startSelected = Instance.new("TextButton", emoteBoxBg)
startSelected.Size = UDim2.new(0.42,0,0,34)
startSelected.Position = UDim2.new(0.04,0,0,210)
startSelected.Text = "Start Selected"
startSelected.BackgroundColor3 = Color3.fromRGB(60,60,60)
startSelected.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", startSelected).CornerRadius = UDim.new(0,6)

local startRandom = Instance.new("TextButton", emoteBoxBg)
startRandom.Size = UDim2.new(0.42,0,0,34)
startRandom.Position = UDim2.new(0.54,0,0,210)
startRandom.Text = "Start Random"
startRandom.BackgroundColor3 = Color3.fromRGB(60,60,60)
startRandom.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", startRandom).CornerRadius = UDim.new(0,6)

local stopBtn = Instance.new("TextButton", emoteBoxBg)
stopBtn.Size = UDim2.new(0.92,0,0,34)
stopBtn.Position = UDim2.new(0.04,0,0,255)
stopBtn.Text = "STOP"
stopBtn.BackgroundColor3 = Color3.fromRGB(150,0,0)
stopBtn.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", stopBtn).CornerRadius = UDim.new(0,6)

local emoteRunning = false
local emoteMode = nil
local emoteSelected = nil

local function getRoot(char) return char and char:FindFirstChild("HumanoidRootPart") end
local function useEmote(name)
    local emoteModule = RS:WaitForChild("Cosmetics"):WaitForChild("KillEmote"):FindFirstChild(name)
    local myRoot = getRoot(localPlayer.Character)
    if not myRoot or not emoteModule then return end
    local target = nil
    local dist = math.huge
    for _,p in ipairs(Players:GetPlayers()) do
        if p ~= localPlayer and p.Character and getRoot(p.Character) then
            local d = (myRoot.Position - getRoot(p.Character).Position).Magnitude
            if d < dist then dist = d; target = p.Character end
        end
    end
    if target then
        pcall(function()
            core.Get("Combat","Ability").Activate(emoteModule,target)
        end)
    end
end

RunService.RenderStepped:Connect(function()
    if emoteRunning then
        if emoteMode == "selected" and emoteSelected then
            useEmote(emoteSelected)
        elseif emoteMode == "random" then
            useEmote(killEmotes[math.random(1,#killEmotes)])
        end
    end
end)

startSelected.MouseButton1Click:Connect(function()
    if dropdown.Text ~= "Select Emote" then
        emoteSelected = dropdown.Text
        emoteRunning = true
        emoteMode = "selected"
    end
end)
startRandom.MouseButton1Click:Connect(function()
    emoteRunning = true
    emoteMode = "random"
end)
stopBtn.MouseButton1Click:Connect(function()
    emoteRunning = false
    emoteMode = nil
end)

-- ensure visible initially
emoteBoxBg.Visible = true



-- ===== REPLACE EXISTING EXPLOITS BLOCK WITH THIS (ScrollingFrame + all buttons) =====
do
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer

    if contentFrame:FindFirstChild("ExploitsScroll") then
        contentFrame.ExploitsScroll:Destroy()
    end
    if contentFrame:FindFirstChild("ExploitsFrame") then
        contentFrame.ExploitsFrame:Destroy()
    end

    local exploitsScroll = Instance.new("ScrollingFrame", contentFrame)
    exploitsScroll.Name = "ExploitsScroll"
    exploitsScroll.Size = UDim2.new(1, 0, 1, 0)
    exploitsScroll.Position = UDim2.new(0, 0, 0, 0)
    exploitsScroll.BackgroundTransparency = 1
    exploitsScroll.ScrollBarThickness = 6
    exploitsScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    exploitsScroll.VerticalScrollBarInset = Enum.ScrollBarInset.Always
    exploitsScroll.ScrollBarImageColor3 = Color3.fromRGB(120,120,120)
    exploitsScroll.ClipsDescendants = true
    exploitsScroll.Visible = false

    local title = Instance.new("TextLabel", exploitsScroll)
    title.Size = UDim2.new(1, -20, 0, 30)
    title.Position = UDim2.new(0, 10, 0, 6)
    title.BackgroundTransparency = 1
    title.Text = "EXPLOITS"
    title.TextColor3 = Color3.fromRGB(255,255,255)
    title.Font = Enum.Font.GothamMedium
    title.TextSize = 18
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextTransparency = 0.03

    local list = Instance.new("UIListLayout", exploitsScroll)
    list.SortOrder = Enum.SortOrder.LayoutOrder
    list.Padding = UDim.new(0,8)
    list.HorizontalAlignment = Enum.HorizontalAlignment.Center

    local pad = Instance.new("UIPadding", exploitsScroll)
    pad.PaddingTop = UDim.new(0,10)
    pad.PaddingLeft = UDim.new(0,10)
    pad.PaddingRight = UDim.new(0,10)
    pad.PaddingBottom = UDim.new(0,12)

    local function createButton(text)
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(1, 0, 0, 36)
        btn.BackgroundColor3 = Color3.fromRGB(44,44,44)
        btn.TextColor3 = Color3.fromRGB(255,255,255)
        btn.Font = Enum.Font.Gotham
        btn.TextSize = 16
        btn.Text = text .. ": OFF"
        btn.AutoButtonColor = true
        local corner = Instance.new("UICorner", btn)
        corner.CornerRadius = UDim.new(0,8)
        btn.Parent = exploitsScroll
        return btn
    end

    local function createTextBox(placeholder, default)
        local tb = Instance.new("TextBox")
        tb.Size = UDim2.new(1, 0, 0, 34)
        tb.BackgroundColor3 = Color3.fromRGB(60,60,60)
        tb.TextColor3 = Color3.fromRGB(255,255,255)
        tb.Font = Enum.Font.Gotham
        tb.TextSize = 14
        tb.PlaceholderText = placeholder
        tb.Text = default or ""
        tb.ClearTextOnFocus = false
        local corner = Instance.new("UICorner", tb)
        corner.CornerRadius = UDim.new(0,8)
        tb.Parent = exploitsScroll
        return tb
    end

    local function makeToggle(name, callback)
        local btn = createButton(name)
        local state = false
        btn.MouseButton1Click:Connect(function()
            state = not state
            btn.Text = name .. ": " .. (state and "ON" or "OFF")
            if callback then
                local ok, err = pcall(function() callback(state, btn) end)
                if not ok then warn("[Exploits] callback error for", name, err) end
            end
        end)
        return btn
    end

    -- ===== SPAM WALL COMBO CODE GI·ªêNG B·∫†N G·ª¨I =====
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Core = require(ReplicatedStorage:WaitForChild("Core"))

local LocalPlayer = Players.LocalPlayer
local charValue = LocalPlayer:WaitForChild("Data"):WaitForChild("Character").Value
local chars = ReplicatedStorage:WaitForChild("Characters")
local ability = chars:WaitForChild(charValue):WaitForChild("WallCombo")
local interruptAttr = ability:GetAttribute("Interrupt")

local wallComboCooldown = 0.05
local lastWallComboTime = 0
local wallComboKey = Enum.KeyCode.E
local lastDashTime = 0

local wallComboEnabled = false
local wallComboConn = nil
local dashConn = nil
local ignoreFriends = false

local function isFriend(player)
    local ok, res = pcall(function() return LocalPlayer:IsFriendsWith(player.UserId) end)
    return ok and res
end

local function shouldIgnorePlayerModel(model)
    if not model then return false end
    if ignoreFriends then
        for _, pl in ipairs(Players:GetPlayers()) do
            if pl ~= LocalPlayer and pl.Character == model then
                if isFriend(pl) then
                    return true
                end
            end
        end
    end
    return false
end

local function getHead()
    local character = LocalPlayer.Character
    if not character then return nil end
    return character:FindFirstChild("Head")
end

local function hasValidTargetsForWallCombo(range)
    local head = getHead()
    if not head then return false end
    local hrpPos = head.Position
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            if not shouldIgnorePlayerModel(pl.Character) then
                local d = (pl.Character.HumanoidRootPart.Position - hrpPos).Magnitude
                if d <= range then return true end
            end
        end
    end
    return false
end

local function executeWallCombo()
    local head = getHead()
    if not head then return end
    local now = tick()
    if now - lastWallComboTime < wallComboCooldown then return end
    if not hasValidTargetsForWallCombo(100) then return end
    lastWallComboTime = now
    local res
    local success = pcall(function()
        res = Core.Get("Combat","Hit").Box(nil, LocalPlayer.Character, {Size = Vector3.new(100,100,100)})
    end)
    if not success or not res then return end
    pcall(function()
        Core.Get("Combat","Ability").Activate(chars[charValue].WallCombo, res, head.Position + Vector3.new(0,0,2.5))
    end)
end

local function fireDash()
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local now = tick()
    if now - lastDashTime < 0.1 then return end
    lastDashTime = now
    local args = {
        [1] = hrp.CFrame,
        [2] = "F",
        [3] = hrp.CFrame.LookVector,
        [5] = now
    }
    if ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("Character") and ReplicatedStorage.Remotes.Character:FindFirstChild("Dash") then
        ReplicatedStorage.Remotes.Character.Dash:FireServer(unpack(args))
    else
        pcall(function()
            ReplicatedStorage.Remotes.Character.Dash:FireServer(unpack(args))
        end)
    end
end

local function toggleWallCombo(state)
    wallComboEnabled = state
    if wallComboConn then wallComboConn:Disconnect(); wallComboConn = nil end
    if dashConn then dashConn:Disconnect(); dashConn = nil end
    if wallComboEnabled then
        wallComboConn = RunService.Heartbeat:Connect(function()
            executeWallCombo()
        end)
        dashConn = RunService.Heartbeat:Connect(function()
            fireDash()
        end)
    end
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == wallComboKey then
        executeWallCombo()
    end
end)

-- ===== TH√äM N√öT SPAM WALL COMBO =====
makeToggle("Spam Wall Combo", function(state)
    toggleWallCombo(state)
    print("Spam Wall Combo:", state and "ON" or "OFF")
end)

    -- ===== C√ÅC CH·ª®C NƒÇNG KH√ÅC GI·ªÆ NGUY√äN =====
    local UserInputService = game:GetService("UserInputService")
    local farmConnection, killAuraConnection, dashConnection
    local originalCameraSubject, originalCameraType
    local savedCFrame, savedCameraCFrame, savedCameraType
    local currentTarget = nil
    local targetStartTime = 0
    local lastDash = 0

    local KillFarmConfig = {
        KillFarming = false,
        FarmKeybind = Enum.KeyCode.F
    }

    -- C·∫•u h√¨nh Kill Aura
    local killAuraRunning = false
    local distance = 100 -- default Kill Aura range
    local KillFarmConfigs = {
        IgnoreFriends = false,
        MaxDistance = distance,
        Damage = 1,
        HealthLimit = 0,
        DashInterval = 0.7
    }

    local function showNotification(title, message)
        print("[" .. title .. "] " .. message)
    end

    local function getRandomAlivePlayer()
        local alive = {}
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= LocalPlayer and p.Character then
                local hum = p.Character:FindFirstChild("Humanoid")
                local hrp = p.Character:FindFirstChild("HumanoidRootPart")
                if hum and hrp and (hum:GetAttribute("Health") or 0) > 0 and not hum:GetAttribute("Godmode") then
                    table.insert(alive, p)
                end
            end
        end
        if #alive > 0 then
            return alive[math.random(1, #alive)]
        end
        return nil
    end

    local function triggerDash()
        if tick() - lastDash < KillFarmConfigs.DashInterval then return end
        lastDash = tick()
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local dashArgs = {[1]=hrp.CFrame,[2]="L",[3]=hrp.CFrame.LookVector,[5]=tick()}
        local dashRemote = ReplicatedStorage.Remotes.Character:FindFirstChild("Dash")
        if dashRemote then pcall(function() dashRemote:FireServer(unpack(dashArgs)) end) end
    end

    local function sendKillAura()
        local Character = LocalPlayer.Character
        if not Character or not Character:FindFirstChild("HumanoidRootPart") then return end
        local CharactersFolder = ReplicatedStorage:FindFirstChild("Characters")
        local RemotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
        if not CharactersFolder or not RemotesFolder then return end
        local AbilitiesRemote = RemotesFolder:FindFirstChild("Abilities")
        local CombatRemote = RemotesFolder:FindFirstChild("Combat")
        if AbilitiesRemote then AbilitiesRemote = AbilitiesRemote:FindFirstChild("Ability") end
        if CombatRemote then CombatRemote = CombatRemote:FindFirstChild("Action") end
        if not AbilitiesRemote or not CombatRemote then return end
        local CharacterName = LocalPlayer:FindFirstChild("Data") and LocalPlayer.Data:FindFirstChild("Character") and LocalPlayer.Data.Character.Value
        if not CharacterName then return end
        local WallCombo = CharactersFolder:FindFirstChild(CharacterName)
        if not WallCombo then return end
        WallCombo = WallCombo:FindFirstChild("WallCombo")
        if not WallCombo then return end
        local localRootPart = Character.HumanoidRootPart
        
        for _, targetPlayer in ipairs(Players:GetPlayers()) do
            if targetPlayer == LocalPlayer then continue end
            if not targetPlayer.Character then continue end
            if not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then continue end
            if KillFarmConfigs.IgnoreFriends and LocalPlayer:IsFriendsWith(targetPlayer.UserId) then continue end
            local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
            local targetRootPart = targetPlayer.Character.HumanoidRootPart
            if not targetHumanoid or targetHumanoid.Health <= KillFarmConfigs.HealthLimit then continue end
            local distanceToTarget = (localRootPart.Position - targetRootPart.Position).Magnitude
            if distanceToTarget > KillFarmConfigs.MaxDistance then continue end
            
            local abilityArgs = {WallCombo, KillFarmConfigs.Damage, {}, targetRootPart.Position}
            pcall(function() AbilitiesRemote:FireServer(unpack(abilityArgs)) end)
            
            local startCFrameStr = tostring(localRootPart.CFrame)
            local combatArgs = {
                WallCombo, CharacterName..":WallCombo", 2,
                KillFarmConfigs.Damage,
                {HitboxCFrames={targetRootPart.CFrame,targetRootPart.CFrame},BestHitCharacter=targetPlayer.Character,HitCharacters={targetPlayer.Character},Ignore={},DeathInfo={},BlockedCharacters={},HitInfo={IsFacing=false,IsInFront=true},ServerTime=os.time(),Actions={ActionNumber1={[targetPlayer.Name]={StartCFrameStr=startCFrameStr,Local=true,Collision=false,Animation="Punch1Hit",Preset="Punch",Velocity=Vector3.zero,FromPosition=targetRootPart.Position,Seed=math.random(1,999999)}}},FromCFrame=targetRootPart.CFrame},
                "Action150",0
            }
            pcall(function() CombatRemote:FireServer(unpack(combatArgs)) end)
        end
    end

    local killAuraConn
    local function startKillAura()
        if killAuraConn then killAuraConn:Disconnect() killAuraConn=nil end
        killAuraConn = RunService.Heartbeat:Connect(function()
            if killAuraRunning then sendKillAura() end
        end)
    end

    local function teleportUnderPlayer(targetPlayer)
        if not targetPlayer or not targetPlayer.Character then return false end
        local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetRoot then return false end
        
        -- Teleport xu·ªëng s√¢u h∆°n d∆∞·ªõi ch√¢n ng∆∞·ªùi ch∆°i
        local belowPos = targetRoot.Position - Vector3.new(0, 10, 0) -- Xu·ªëng 10 studs
        pcall(function()
            require(LocalPlayer.PlayerScripts.Character.FullCustomReplication).Override(LocalPlayer.Character, CFrame.new(belowPos))
        end)
        
        if currentTarget ~= targetPlayer.Character then
            currentTarget = targetPlayer.Character
            targetStartTime = tick()
        end
        return true
    end

    local function spectatePlayer(targetPlayer)
        local cam = workspace.CurrentCamera
        if not cam or not targetPlayer or not targetPlayer.Character then return end
        local hum = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            cam.CameraType = Enum.CameraType.Custom
            cam.CameraSubject = hum
        else
            local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                cam.CameraType = Enum.CameraType.Scriptable
                cam.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 10, 15), hrp.Position)
            end
        end
    end

    local function lpdash()
        triggerDash()
    end

    local function farmLoop()
        local char = LocalPlayer.Character
        if not char or not char.Parent then return end
        
        if currentTarget and (tick() - targetStartTime) < 0.7 then
            local targetPlayer = nil
            for _, p in ipairs(Players:GetPlayers()) do
                if p.Character == currentTarget then
                    targetPlayer = p
                    break
                end
            end
            if targetPlayer then
                teleportUnderPlayer(targetPlayer)
                spectatePlayer(targetPlayer)
            else
                currentTarget = nil
            end
        else
            local randomPlayer = getRandomAlivePlayer()
            if randomPlayer then
                teleportUnderPlayer(randomPlayer)
                spectatePlayer(randomPlayer)
            end
        end
    end

    local function setGravity(enabled)
        local char = LocalPlayer.Character
        if not char then return end
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = not enabled
                if not enabled then
                    part.Velocity = Vector3.new(0, 0, 0)
                    part.RotVelocity = Vector3.new(0, 0, 0)
                end
            end
        end
    end

    local function savePosition()
        local char = LocalPlayer.Character
        if not char then return false end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        savedCFrame = hrp.CFrame
        local cam = workspace.CurrentCamera
        if cam then
            savedCameraCFrame = cam.CFrame
            savedCameraType = cam.CameraType
        end
        return true
    end

    local function restorePosition()
        if not savedCFrame then return end
        
        local char = LocalPlayer.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        pcall(function()
            require(LocalPlayer.PlayerScripts.Character.FullCustomReplication).Override(char, savedCFrame)
        end)
        
        task.spawn(function()
            task.wait(0.1)
            local cam = workspace.CurrentCamera
            if cam and savedCameraCFrame and savedCameraType then
                cam.CameraType = savedCameraType
                if savedCameraType == Enum.CameraType.Scriptable then
                    cam.CFrame = savedCameraCFrame
                end
            end
        end)
    end

    local function startKillFarming()
        if KillFarmConfig.KillFarming then return end
        if not savePosition() then return end
        
        KillFarmConfig.KillFarming = true
        killAuraRunning = true
        setGravity(false)
        local cam = workspace.CurrentCamera
        if cam then
            originalCameraSubject = cam.CameraSubject
            originalCameraType = cam.CameraType
        end
        farmConnection = RunService.Heartbeat:Connect(farmLoop)
        startKillAura()
        dashConnection = RunService.Heartbeat:Connect(lpdash)
        showNotification("Kill Farm", "Kill farming with new kill aura started!")
    end

    local function stopKillFarming()
        if not KillFarmConfig.KillFarming then return end
        KillFarmConfig.KillFarming = false
        killAuraRunning = false
        if farmConnection then farmConnection:Disconnect(); farmConnection = nil end
        if killAuraConn then killAuraConn:Disconnect(); killAuraConn = nil end
        if dashConnection then dashConnection:Disconnect(); dashConnection = nil end
        
        currentTarget = nil
        targetStartTime = 0
        restorePosition()
        
        setGravity(true)
        local cam = workspace.CurrentCamera
        if cam then
            if originalCameraSubject then
                cam.CameraSubject = originalCameraSubject
                cam.CameraType = originalCameraType or Enum.CameraType.Custom
            end
        end
        showNotification("Kill Farm", "Kill farming stopped!")
    end

    local function toggleKillFarming()
        if KillFarmConfig.KillFarming then
            stopKillFarming()
        else
            startKillFarming()
        end
    end

    -- Auto reconnect when character respawns
    LocalPlayer.CharacterAdded:Connect(function()
        stopKillFarming()
        setGravity(true)
        currentTarget = nil
        targetStartTime = 0
        killAuraRunning = false
    end)

    -- ===== T·∫†O C√ÅC N√öT CH·ª®C NƒÇNG =====
    makeToggle("No Stun", function(state)
        Tab:Toggle({
            Title = "ÂèñÊ∂àË¢´ÊîªÂáªÁ°¨Áõ¥",
            Value = false,
            Callback = function(state)
                settings.Toggles.DisableHitStun.Value = state
            end
        })
        print("No Stun", state)
    end)

    local active = false

    local function buildCombatArgs()
        return {
            [1] = ReplicatedStorage.Characters.Gon.WallCombo,
            [2] = "Characters:Gon:WallCombo",
            [3] = 1,
            [4] = 33036,
            [5] = {
                ["HitboxCFrames"] = {},
                ["BestHitCharacter"] = workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum"),
                ["HitCharacters"] = {workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum")},
                ["Ignore"] = {},
                ["DeathInfo"] = {},
                ["Actions"] = {},
                ["HitInfo"] = {
                    ["IsFacing"] = true,
                    ["IsInFront"] = true
                },
                ["BlockedCharacters"] = {},
                ["ServerTime"] = os.clock(),
                ["FromCFrame"] = CFrame.new(534.693, 5.532, 79.486)
            },
            [6] = "Action651",
            [7] = 0
        }
    end

    local abilityArgs = {
        [1] = ReplicatedStorage.Characters.Gon.WallCombo,
        [2] = 33036,
        [4] = workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum"),
        [5] = Vector3.new(527.693, 4.532, 79.978)
    }

    local function instantHitBurst()
        local combatArgs = buildCombatArgs()
        pcall(function()
            ReplicatedStorage.Remotes.Abilities.Ability:FireServer(unpack(abilityArgs))
            ReplicatedStorage.Remotes.Combat.Action:FireServer(unpack(combatArgs))
        end)
    end

    spawn(function()
        while true do
            task.wait()
            if active then
                for i = 1, 5 do
                    instantHitBurst()
                end
            end
        end
    end)

    makeToggle("Lag Sever", function(state)
        active = state
        print("Godmode Active", state)
    end)

    makeToggle("Kill Farming Beta", function(state)
        if state then
            startKillFarming()
        else
            stopKillFarming()
        end
        print("Kill Farming Beta:", state and "ON" or "OFF")
    end)

    -- ===== TH√äM 3 N√öT CH·ª®C NƒÇNG M·ªöI =====
    makeToggle("God Mode V1", function(state)
    godModeEnabled = state
    
    if state then
        spawn(function()
            while godModeEnabled do
                local combatArgs = {
                    [1] = ReplicatedStorage.Characters.Gon.WallCombo,
                    [2] = "Characters:Gon:WallCombo",
                    [3] = 1,
                    [4] = 33036,
                    [5] = {
                        ["HitboxCFrames"] = {},
                        ["BestHitCharacter"] = workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum"),
                        ["HitCharacters"] = {workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum")},
                        ["Ignore"] = {},
                        ["DeathInfo"] = {},
                        ["Actions"] = {},
                        ["HitInfo"] = {
                            ["IsFacing"] = true,
                            ["IsInFront"] = true
                        },
                        ["BlockedCharacters"] = {},
                        ["ServerTime"] = os.clock(),
                        ["FromCFrame"] = CFrame.new(534.693, 5.532, 79.486)
                    },
                    [6] = "Action651",
                    [7] = 0
                }

                local abilityArgs = {
                    [1] = ReplicatedStorage.Characters.Gon.WallCombo,
                    [2] = 33036,
                    [4] = workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum"),
                    [5] = Vector3.new(527.693, 4.532, 79.978)
                }

                pcall(function()
                    ReplicatedStorage.Remotes.Abilities.Ability:FireServer(unpack(abilityArgs))
                    ReplicatedStorage.Remotes.Combat.Action:FireServer(unpack(combatArgs))
                end)
                task.wait(1.4)
            end
        end)
        
        showNotification("God Mode V1", "God Mode V1 activated!")
    else
        showNotification("God Mode V1", "God Mode V1 deactivated!")
    end
    print("God Mode V1:", state and "ON" or "OFF")
end)


    makeToggle("God Mode V2", function(state)
    godModeEnabled = state
    
    if state then
        task.spawn(function()
            while godModeEnabled do
                pcall(function()
                    local playerChar = LocalPlayer.Character
                    if not playerChar then return end

                    local head = playerChar:FindFirstChild("Head")
                    if not head then return end

                    local charData = LocalPlayer:FindFirstChild("Data")
                    local charValue = charData and charData:FindFirstChild("Character") and charData.Character.Value
                    if not charValue then return end

                    local charsFolder = ReplicatedStorage:FindFirstChild("Characters")
                    if not charsFolder or not charsFolder:FindFirstChild(charValue) then return end

                    local wallComboAbility = charsFolder[charValue]:FindFirstChild("WallCombo")
                    if not wallComboAbility then return end

                    local targetCharacter = playerChar
                    if not targetCharacter then return end

                    local actionNumber = "Action" .. math.random(1000, 9999)
                    local serverTime = tick()
                    local randomId = math.random(100000, 999999)

                    local remoteArgs = {
                        wallComboAbility,
                        "Characters:" .. charValue .. ":WallCombo",
                        1,
                        randomId,
                        {
                            HitboxCFrames = {nil},
                            BestHitCharacter = targetCharacter,
                            HitCharacters = {targetCharacter},
                            Ignore = {[actionNumber] = {targetCharacter}},
                            DeathInfo = {},
                            Actions = {[actionNumber] = {}},
                            HitInfo = {
                                Blocked = false,
                                IsFacing = true,
                                IsInFront = true
                            },
                            BlockedCharacters = {},
                            ServerTime = serverTime,
                            FromCFrame = nil
                        },
                        actionNumber
                    }

                    ReplicatedStorage.Remotes.Abilities.Ability:FireServer(wallComboAbility, randomId)
                    ReplicatedStorage.Remotes.Combat.Action:FireServer(unpack(remoteArgs))
                end)
                task.wait(0.01)
            end
        end)
        
        showNotification("God Mode V2", "God Mode V2 activated!")
    else
        showNotification("God Mode V2", "God Mode V2 deactivated!")
    end
    print("God Mode V2:", state and "ON" or "OFF")
end)

    makeToggle("Crack Sever Rank", function(state)
    if state then
        local crackActive = true
        local autoUseEnabled = true
        local lastUseTime = 0
        local useCooldown = 0.0000000000000000001
        local spamCounter = 0

        local KILL_EMOTE_NAME = "Pollen Overload"
        local killEmoteObject = ReplicatedStorage:WaitForChild("Cosmetics"):WaitForChild("KillEmote"):WaitForChild(KILL_EMOTE_NAME)
        local AbilityRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Abilities"):WaitForChild("Ability")
        local CombatRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("Action")

        local ActionIDCounter = 0
        local cachedTarget = nil
        local lastTargetCheck = 0

        local function generateActionID()
            ActionIDCounter = ActionIDCounter + 1
            return ActionIDCounter + math.random(10000, 50000)
        end

        local function generateActionName()
            return "UltraAction" .. math.random(10000, 99999)
        end

        local function findNearestPlayerUltra()
            local now = tick()
            if cachedTarget and now - lastTargetCheck < 0.5 then
                if cachedTarget.Character and cachedTarget.Character:FindFirstChild("HumanoidRootPart") then
                    return cachedTarget
                end
            end
            
            local character = LocalPlayer.Character
            if not character then return nil end
            
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then return nil end
            
            local localPos = humanoidRootPart.Position
            local nearestPlayer = nil
            local shortestDistance = 50
            
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                    if targetRoot then
                        local distance = (localPos - targetRoot.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestPlayer = player
                        end
                    end
                end
            end
            
            cachedTarget = nearestPlayer
            lastTargetCheck = now
            return nearestPlayer
        end

        local function generateKillEmoteCFramesFast(localChar, targetChar)
            local localRoot = localChar:FindFirstChild("HumanoidRootPart")
            local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
            
            if not localRoot or not targetRoot then return nil end
            
            local localPos = localRoot.Position
            local targetPos = targetRoot.Position
            
            return {
                fromCFrame = CFrame.new(localPos, targetPos),
                targetCFrame = CFrame.new(targetPos),
                phase1Vector = Vector3.new(0, 1, 0),
                phase2Vector = Vector3.new(0, 0, -1),
                lookVector = (targetPos - localPos).Unit
            }
        end

        local function usePollenOverloadUltra()
            local targetPlayer = findNearestPlayerUltra()
            if not targetPlayer or not targetPlayer.Character then
                return false
            end
            
            local localChar = LocalPlayer.Character
            if not localChar then return false end
            
            local cframes = generateKillEmoteCFramesFast(localChar, targetPlayer.Character)
            if not cframes then return false end
            
            local actionId = generateActionID()
            local serverTime = tick()
            
            local abilityArgs = {
                killEmoteObject,
                actionId,
                [4] = targetPlayer.Character
            }
            
            local combatArgs1 = {
                killEmoteObject,
                "Cosmetics:KillEmote:" .. KILL_EMOTE_NAME,
                1,
                actionId,
                {
                    HitboxCFrames = {},
                    BestHitCharacter = targetPlayer.Character,
                    HitCharacters = {targetPlayer.Character},
                    Ignore = {},
                    DeathInfo = {
                        {
                            targetPlayer.Character,
                            cframes.targetCFrame,
                            cframes.phase1Vector,
                            false
                        }
                    },
                    BlockedCharacters = {},
                    HitInfo = {
                        IsFacing = true,
                        GetUp = true,
                        IsInFront = true,
                        Blocked = false
                    },
                    ServerTime = serverTime,
                    Actions = {},
                    FromCFrame = cframes.fromCFrame
                },
                generateActionName(),
                0.01
            }
            
            local combatArgs2 = {
                killEmoteObject,
                "Cosmetics:KillEmote:" .. KILL_EMOTE_NAME,
                2,
                actionId,
                {
                    HitboxCFrames = {},
                    BestHitCharacter = targetPlayer.Character,
                    HitCharacters = {targetPlayer.Character},
                    Ignore = {},
                    DeathInfo = {
                        {
                            targetPlayer.Character,
                            cframes.targetCFrame,
                            cframes.phase2Vector,
                            false
                        }
                    },
                    BlockedCharacters = {},
                    HitInfo = {
                        IsFacing = true,
                        IsInFront = false,
                        Blocked = false
                    },
                    ServerTime = serverTime + 1,
                    Actions = {
                        ActionNumber1 = {
                            [targetPlayer.Name] = {
                                StartCFrameStr = tostring(cframes.targetCFrame),
                                Finished = true,
                                AbilityName = KILL_EMOTE_NAME,
                                RotVelocityStr = "0,0,0",
                                VelocityStr = "0,0,0",
                                Duration = 1,
                                RotImpulseVelocity = Vector3.new(0, 0, 0),
                                Seed = math.random(100000000, 999999999),
                                LookVectorStr = tostring(cframes.lookVector),
                                NoCollisions = true,
                                ImpulseVelocity = Vector3.new(0, 100000, 0)
                            }
                        }
                    },
                    FromCFrame = cframes.fromCFrame
                },
                generateActionName(),
                0.01
            }
            
            AbilityRemote:FireServer(unpack(abilityArgs))
            CombatRemote:FireServer(unpack(combatArgs1))
            CombatRemote:FireServer(unpack(combatArgs2))
            
            spamCounter = spamCounter + 1
            return true
        end

        RunService.Heartbeat:Connect(function()
            if autoUseEnabled and crackActive then
                local currentTime = tick()
                if currentTime - lastUseTime >= useCooldown then
                    for i = 1, 3 do
                        local success = usePollenOverloadUltra()
                        if success then
                            lastUseTime = currentTime
                        end
                    end
                end
            end
        end)
        
        showNotification("Crack Sever Rank", "Ultra speed Pollen Overload activated!")
    else
        crackActive = false
        autoUseEnabled = false
        showNotification("Crack Sever Rank", "Crack server rank deactivated!")
    end
    print("Crack Sever Rank:", state and "ON" or "OFF")
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == KillFarmConfig.FarmKeybind then
        toggleKillFarming()
    end
end)

list:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    pcall(function()
        exploitsScroll.CanvasSize = UDim2.new(0,0,0, list.AbsoluteContentSize.Y + 12)
    end)
end)

if tabExploitBtn then
    tabExploitBtn.MouseButton1Click:Connect(function()
        if combatFrame then combatFrame.Visible = false end
        if utilFrame then utilFrame.Visible = false end
        exploitsScroll.Visible = true
    end)
end

exploitsFrame = exploitsScroll
print("[Exploits] ScrollingFrame created with new Spam Wall Combo + all features")
end

print("[KFC HUB] Merged script loaded with Spam Wall Combo feature.")
